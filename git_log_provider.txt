commit 3a6aea7ad7a9d26d51fbd8bd5f389c86c2eb06f3
Author: polaralias <76123410+polaralias@users.noreply.github.com>
Date:   Mon Feb 23 18:19:43 2026 +0000

    updating

diff --git a/packages/polar-runtime-core/src/provider-gateway.mjs b/packages/polar-runtime-core/src/provider-gateway.mjs
index 010f116..6d21a06 100644
--- a/packages/polar-runtime-core/src/provider-gateway.mjs
+++ b/packages/polar-runtime-core/src/provider-gateway.mjs
@@ -7,6 +7,7 @@ import {
   createProviderOperationContracts,
   createStrictObjectSchema,
   enumField,
+  numberField,
   stringArrayField,
   stringField,
 } from "../../polar-domain/src/index.mjs";
@@ -22,6 +23,8 @@ const generateRequestSchema = createStrictObjectSchema({
     fallbackProviderIds: stringArrayField({ minItems: 1, required: false }),
     model: stringField({ minLength: 1 }),
     prompt: stringField({ minLength: 1 }),
+    modelLane: enumField(["local", "worker", "brain"], { required: false }),
+    estimatedCostUsd: numberField({ min: 0, required: false }),
   },
 });
 
@@ -34,6 +37,8 @@ const streamRequestSchema = createStrictObjectSchema({
     fallbackProviderIds: stringArrayField({ minItems: 1, required: false }),
     model: stringField({ minLength: 1 }),
     prompt: stringField({ minLength: 1 }),
+    modelLane: enumField(["local", "worker", "brain"], { required: false }),
+    estimatedCostUsd: numberField({ min: 0, required: false }),
   },
 });
 
@@ -46,6 +51,8 @@ const embedRequestSchema = createStrictObjectSchema({
     fallbackProviderIds: stringArrayField({ minItems: 1, required: false }),
     model: stringField({ minLength: 1 }),
     text: stringField({ minLength: 1 }),
+    modelLane: enumField(["local", "worker", "brain"], { required: false }),
+    estimatedCostUsd: numberField({ min: 0, required: false }),
   },
 });
 
@@ -160,6 +167,16 @@ function shouldTryFallback(error) {
   return true;
 }
 
+/**
+ * @param {() => number} now
+ * @returns {string}
+ */
+function createProviderTraceId(now) {
+  return `trace-provider-${now().toString(16)}-${Math.random()
+    .toString(16)
+    .slice(2, 10)}`;
+}
+
 /**
  * @param {ReturnType<import("./contract-registry.mjs").createContractRegistry>} contractRegistry
  */
@@ -179,13 +196,35 @@ export function registerProviderOperationContracts(contractRegistry) {
  *     operation: "generate"|"stream"|"embed",
  *     providerId: string,
  *     fallbackProviderIds?: readonly string[]
- *   }) => readonly string[]
+ *   }) => readonly string[],
+ *   usageTelemetryCollector?: {
+ *     recordOperation: (event: {
+ *       traceId: string,
+ *       actionId: string,
+ *       operation: "generate"|"stream"|"embed",
+ *       executionType: "tool"|"handoff"|"automation"|"heartbeat",
+ *       requestedProviderId: string,
+ *       providerId: string,
+ *       attemptedProviderIds: readonly string[],
+ *       fallbackProviderIds?: readonly string[],
+ *       fallbackUsed: boolean,
+ *       status: "completed"|"failed",
+ *       durationMs: number,
+ *       model: string,
+ *       modelLane?: "local"|"worker"|"brain",
+ *       estimatedCostUsd?: number,
+ *       errorCode?: string
+ *     }) => Promise<void>|void
+ *   },
+ *   now?: () => number
  * }} config
  */
 export function createProviderGateway({
   middlewarePipeline,
   providers,
   resolveFallbackOrder,
+  usageTelemetryCollector = { async recordOperation() {} },
+  now = Date.now,
 }) {
   const providerEntries =
     providers instanceof Map ? [...providers.entries()] : Object.entries(providers);
@@ -213,6 +252,20 @@ export function createProviderGateway({
     }
   }
 
+  if (
+    typeof usageTelemetryCollector !== "object" ||
+    usageTelemetryCollector === null ||
+    typeof usageTelemetryCollector.recordOperation !== "function"
+  ) {
+    throw new RuntimeExecutionError(
+      "usageTelemetryCollector must expose recordOperation(event)",
+    );
+  }
+
+  if (typeof now !== "function") {
+    throw new RuntimeExecutionError("now must be a function when provided");
+  }
+
   /**
    * @param {{
    *   operation: "generate"|"stream"|"embed",
@@ -228,6 +281,14 @@ export function createProviderGateway({
     const requestFallbackProviderIds = /** @type {readonly string[]|undefined} */ (
       params.validatedRequest.fallbackProviderIds
     );
+    const executionType =
+      /** @type {"tool"|"handoff"|"automation"|"heartbeat"|undefined} */ (
+        params.validatedRequest.executionType
+      ) ?? "tool";
+    const traceId =
+      /** @type {string|undefined} */ (params.validatedRequest.traceId) ??
+      createProviderTraceId(now);
+    const operationStartedAtMs = now();
 
     const providerOrder = resolveFallbackOrder
       ? Object.freeze(
@@ -252,6 +313,10 @@ export function createProviderGateway({
       );
     }
 
+    const fallbackProviderIds = requestFallbackProviderIds
+      ? Object.freeze([...requestFallbackProviderIds])
+      : undefined;
+
     const attempts = [];
     for (let index = 0; index < providerOrder.length; index += 1) {
       const providerId = providerOrder[index];
@@ -259,10 +324,10 @@ export function createProviderGateway({
       const isLastProvider = index === providerOrder.length - 1;
 
       try {
-        return await middlewarePipeline.run(
+        const output = await middlewarePipeline.run(
           {
-            executionType: params.validatedRequest.executionType ?? "tool",
-            traceId: params.validatedRequest.traceId,
+            executionType,
+            traceId,
             actionId: params.actionId,
             version: params.version,
             input: params.buildInput(params.validatedRequest, providerId),
@@ -272,6 +337,42 @@ export function createProviderGateway({
             return await operation(validatedInput);
           },
         );
+
+        const attemptedProviderIds = Object.freeze([
+          ...attempts.map((attempt) => attempt.providerId),
+          providerId,
+        ]);
+        const telemetryEvent = {
+          traceId,
+          actionId: params.actionId,
+          operation: params.operation,
+          executionType,
+          requestedProviderId: requestProviderId,
+          providerId,
+          attemptedProviderIds,
+          fallbackUsed: providerId !== requestProviderId || attempts.length > 0,
+          status: "completed",
+          durationMs: Math.max(0, now() - operationStartedAtMs),
+          model: /** @type {string} */ (params.validatedRequest.model),
+        };
+
+        if (fallbackProviderIds !== undefined) {
+          telemetryEvent.fallbackProviderIds = fallbackProviderIds;
+        }
+        if (params.validatedRequest.modelLane !== undefined) {
+          telemetryEvent.modelLane =
+            /** @type {"local"|"worker"|"brain"} */ (
+              params.validatedRequest.modelLane
+            );
+        }
+        if (params.validatedRequest.estimatedCostUsd !== undefined) {
+          telemetryEvent.estimatedCostUsd =
+            /** @type {number} */ (params.validatedRequest.estimatedCostUsd);
+        }
+
+        await usageTelemetryCollector.recordOperation(telemetryEvent);
+
+        return output;
       } catch (error) {
         const normalized = normalizeTypedError(error);
         attempts.push(
@@ -283,17 +384,49 @@ export function createProviderGateway({
         );
 
         if (isLastProvider || !shouldTryFallback(normalized)) {
-          if (attempts.length === 1 && isLastProvider) {
-            throw normalized;
+          const terminalError =
+            attempts.length === 1 && isLastProvider
+              ? normalized
+              : new RuntimeExecutionError(
+                  `All providers failed for ${params.operation}`,
+                  {
+                    operation: params.operation,
+                    attempts: Object.freeze([...attempts]),
+                  },
+                );
+          const telemetryEvent = {
+            traceId,
+            actionId: params.actionId,
+            operation: params.operation,
+            executionType,
+            requestedProviderId: requestProviderId,
+            providerId,
+            attemptedProviderIds: Object.freeze([
+              ...attempts.map((attempt) => attempt.providerId),
+            ]),
+            fallbackUsed: providerId !== requestProviderId || attempts.length > 1,
+            status: "failed",
+            durationMs: Math.max(0, now() - operationStartedAtMs),
+            model: /** @type {string} */ (params.validatedRequest.model),
+            errorCode: terminalError.code,
+          };
+
+          if (fallbackProviderIds !== undefined) {
+            telemetryEvent.fallbackProviderIds = fallbackProviderIds;
+          }
+          if (params.validatedRequest.modelLane !== undefined) {
+            telemetryEvent.modelLane =
+              /** @type {"local"|"worker"|"brain"} */ (
+                params.validatedRequest.modelLane
+              );
+          }
+          if (params.validatedRequest.estimatedCostUsd !== undefined) {
+            telemetryEvent.estimatedCostUsd =
+              /** @type {number} */ (params.validatedRequest.estimatedCostUsd);
           }
 
-          throw new RuntimeExecutionError(
-            `All providers failed for ${params.operation}`,
-            {
-              operation: params.operation,
-              attempts: Object.freeze([...attempts]),
-            },
-          );
+          await usageTelemetryCollector.recordOperation(telemetryEvent);
+          throw terminalError;
         }
       }
     }
