# Skill Registry, Installation, And Metadata

Last updated: 2026-02-28

## Purpose
This document defines how Polar supports extensibility (users add skills and use them in chat and multi-agent workflows) while staying safe:

- Tools must declare risk metadata via MCP.
- New skills can be **proposed** by an LLM (cheap model), but are only **installed/enabled** after deterministic validation.
- Skill capability allowlists and constraints are policy-driven and centrally enforced.

This document is an addendum to:
- `docs/architecture/deterministic-orchestration-architecture.md`

---

## Core concepts

### Skill
A skill is a packaged set of capabilities exposed via an MCP server or extension gateway.

### Capability
A specific callable action:
- `{ extensionId, capabilityId }`
- with input/output schemas and risk metadata

### Skill registry
Server-owned registry containing:
- installed skills
- capabilities and metadata
- policy allowlists and constraints
- versioning and enable/disable state

---

## MCP metadata is authoritative

### Required metadata per capability
At minimum:
- `riskLevel`: `read | write | destructive`
- `sideEffects`: `none | internal | external`
- `inputSchema` (JSON Schema or equivalent)
- `outputSchema` (optional but preferred)

If MCP does not provide this metadata:
- installation is blocked by default
- user must supply missing metadata per capability (see “Metadata completion”)

Rationale: risk cannot be left to the LLM or inferred heuristically.

---

## Skill install flows

### A) Manual install (current)
Current flow (eg SKILL.md or manifest files installed manually) remains supported:
- operator adds skill manifest
- registry loads and validates
- skill becomes available subject to policy

## Install-time manifest generation (LLM-assisted, HITL)

This section clarifies the intended end state: **LLM assistance happens at install-time only**. The runtime never regenerates or “interprets” skill manifests during normal operation.

### Goal
When a user adds an Agent Skills package (folder containing `SKILL.md` and resources), Polar should:
1) Analyse it once at install time (cheap/local model).
2) Produce a proposed `SkillManifest`.
3) Validate deterministically against MCP introspection + policy.
4) Require a human approval step (HITL).
5) Install the approved manifest and treat it as the runtime source of truth.

### Why this is required
- Prevents incorrect manifests from affecting runtime execution.
- Avoids token burn and non-determinism during normal tool use.
- Creates a clear audit trail: “this manifest was approved on date X”.

### Flow

1) **Skill added (not enabled)**
- User adds a skill package (Agent Skills standard).
- Skill is registered as `pending_install` and **not enabled**.

2) **LLM install analysis (cheap model)**
- Inputs:
  - `SKILL.md`
  - MCP tool inventory (introspection result)
- Outputs:
  - Proposed `SkillManifest` mapping “what the skill claims” to actual `{extensionId, capabilityId}`.
- Constraints:
  - LLM cannot invent tools that do not exist in MCP introspection.
  - LLM cannot decide risk metadata.

3) **Deterministic validation (code)**
Before presenting anything to the user, code validates:
- Every capability exists in MCP introspection.
- Required metadata exists per capability:
  - `riskLevel`, `sideEffects` (and `dataEgress` if applicable).
- Policy constraints are satisfied (domains, rate limits, etc).

If metadata is missing:
- Installation is blocked.
- UI must request per-capability completion plus explanation.
- Skill remains disabled until complete.

4) **HITL approval**
User approves:
- enabled capabilities list
- risk classification (as provided by MCP or operator override)
- any policy constraints and approval defaults

5) **Install + enable**
- Approved manifest is stored in the SkillRegistry.
- Skill becomes enabled subject to policy.
- Runtime uses the installed manifest + policy projection for `capabilityScope`.

### Runtime rule (non-negotiable)
After installation:
- The orchestrator/planner may use the installed manifest for discovery and workflow planning.
- The runtime must never call the install planner to regenerate/adjust manifests automatically.

### Artefacts to persist
Recommended to store:
- `manifest.proposed.json` (pre-approval proposal, for traceability)
- `manifest.json` (installed, approved source of truth)
- `install_report.json` (validation results and any operator overrides)


## Skill manifest shape (proposed)
Minimum fields:

- `skillId`, `version`
- `provider`: `{ type: "mcp", serverId: "..." }`
- `capabilities[]`:
  - `extensionId`, `capabilityId`
  - `riskLevel`, `sideEffects` (must match MCP)
  - `inputSchemaRef` / inline schema
  - optional constraints
- `defaultPolicyHints` (non-authoritative)

Manifest can be generated by LLM, but it is not installed until validated.

---

## Metadata completion (missing risk)
If a skill’s MCP metadata is incomplete:
- the skill remains **blocked**
- user/admin must provide missing per-capability fields:
  - `riskLevel`
  - `sideEffects`
  - optionally constraints

This should be an explicit UI flow:
- list missing fields
- require an explanation per capability (why classified this way)
- store overrides in the registry as “operator supplied”

---

## Capability allowlisting and projection
The runtime never uses “skills strings” directly for permission.

Instead:
1) Resolve enabled capabilities from SkillRegistry + PolicyStore.
2) Project to a `capabilityScope`:
   - allowed extensions
   - allowed capability IDs per extension
   - constraints (domains/paths/rate limits)
3) Enforce in `extensionGateway.policy.evaluateExecution(...)`.

---

## Multi-agent implications
Sub-agents:
- run with least privilege
- can only access capabilities explicitly forwarded and allowlisted
- forwarded skills are treated as untrusted input and intersected with policy+registry

Skill install planner must not run inside a sub-agent unless policy allows it.

---

## Acceptance criteria
- No skill can be enabled without per-capability risk metadata.
- LLM can propose manifests, but code validates and installs.
- CapabilityScope is always derived from registry+policy, not from the prompt.
- Newly installed skills become available to the orchestrator and to sub-agents via the same allowlist machinery.
